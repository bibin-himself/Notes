

HOOKS

> Functions that provide functional components with the ability to use states, LC methods and manage side effects.
> Pass custom data to your component
> share state between components
> Reuse logic
> Extract logic from components and share it between components



> useState : 
  > Manage states. 
  > Returns a STATEFUL VALUE and an UPDATER FUNCTION to update it.

  > EXAMPLE: 
            function Counter() {
            const [count, setCount] = useState(0);

             return (
                <div>
                <p>Count: {count}</p>
                <button onClick={() => setCount(count + 1)} >Increment</button>
                </div>
            );
            }




> useEffect : 
  > Manage side-effects like API calls, subscriptions, timers, mutations

  > Mimic componentDidMount, componentDidUpdate, and componentWillUnmount
  
  > EXAMPLE:
           function Timer() {
           const [seconds, setSeconds] = useState(0);

            useEffect(() => {
                const interval = setInterval(() => {
                setSeconds(prevSeconds => prevSeconds + 1);
                }, 1000);

                // Cleanup interval on unmount
            return () => clearInterval(interval);
            }, []); 
             // Empty array means this effect only runs once on mount

            return <p>Seconds: {seconds}</p>;
            }



///////////////////
          const dataFetchComp = () => {
              const [data, setData] = useState(null);
              const [error, setError] = useState(null)

              const fetchData = async () => {
                setError(null);

                try {
                const response = await fetch ("data-end-point");

                if(!response.ok){
                  throw new Error("Some Issues");
                }

                const result = await response.json();
                setData(result);
              }catch(err){
                setError(err.message)
              }
              }
          

          useEffect(() => {
            fetchData();
          }, [])


          if (error) return <div>Error: {error}</div>; // Render error message

          return <div>{data ? data.title : "Loading..."}</div>;
          }

          //// to implement data fetching throug button click, 
          //// take fetchData() out of useEffect and add it in a button
          
/////////////////////////




> useContext :
  > Return the current value for a context.
  > Allows you to ACCESS CONTEXT VALUES without having to pass props down manually
  > create context ( createContext() ) -->  consume context ( contextname.provider )  --> Wrap the context
  > useContext() used for access values


  >EXAMPLE: 
        import React, { useContext } from 'react';

        const ThemeContext = React.createContext('light');

        function ThemeSwitcher() {
        const theme = useContext(ThemeContext);

       return <p>Current theme: {theme}</p>;
       }

       export default function App() {
       return (
       <ThemeContext.Provider value="dark">
       <ThemeSwitcher />
       </ThemeContext.Provider>
       );
       }



> useReducer : 
  > similar to useState
  > Manging complex state management
  > use reducer functionngn
  > Used when next state depends on previous state
  > const [state, dispatch] = useReducer(reducer, initial)

  >EXAMPLE : 
            import React, { useEffect } from "react";
            import { useReducer, useState } from "react";
            
            const initialState = { count: 0 };
            
            const reducer = (state, action) => {
              switch (action.type) {
                case "INCREMENT":
                  return {
                    count: state.count + action.payload,
                  };
            
                case "DECREMENT":
                  return {
                    count: state.count - action.payload,
                  };
            
                case "RESET":
                  return {
                    count: initialState.count,
                  };
                default:
                  return state;
              }
            };
            
            
            const Rough = () => {
            
                const [state, dispatch] = useReducer(reducer, initialState);
            
                ///optional
                const [delayedCount, setDelayedCount] = useState(0);
            
            
                ///optional
                useEffect(() => {
                  const timer = setTimeout(() => {
                    setDelayedCount(state.count);
                  }, 3000);
            
                  return () => clearTimeout(timer);
                }, [state.count])
                
            
            
                
              return (
              
              <>
              <h2>{delayedCount}</h2>
              <button onClick={() => dispatch({ type: 'INCREMENT', payload: 1})}>ADD</button>
              <button onClick={() => dispatch({type:'DECREMENT', payload: 1})}>Sub</button>
              <button onClick={() => dispatch({type: 'RESET'})}>Reset</button>
              </>
            );
            };
            
            export default Rough;


> useRef : 
  > Accesses DOM elements directly
  > stores mutable values
  > without triggering re-render



> useMemo : 
  > Use when you want to memoize the result of a computation to avoid recalculating it unnecessarily.
  > Optimizes performance by memoizing expensive calculations.
  > memoize return value if no dependencies have changed.
  > Memoizing means storing the value as a cached value 
  > improves performance

  > const memoizedValue = useMemo(() => computeExpensiveValue(dependencies), [dependencies]);

  >EXAMPLE : 
          import React, { useMemo, useState } from 'react';

          function ExpensiveCalculation({ numbers }) {
    const [count, setCount] = useState(0);

    // Memoizing the expensive computation
    const total = useMemo(() => {
        console.log('Calculating...');
        return numbers.reduce((sum, num) => sum + num, 0);
    }, [numbers]);

    return (
        <div>
            <p>Total: {total}</p>
            <button onClick={() => setCount(count + 1)}>Re-render ({count})</button>
        </div>
    );
}


            import React, { useMemo, useState } from 'react';

            function calculate() {
             let result = 0;
             for (let i = 0; i < 1000000000; i++) {
               result += i;
             }
             return result;
           }

           function App1() {
             const [count, setCount] = useState(0);

             const value = calculate();

             return (
               <div className="App">
                 <button onClick={() => setCount(count + 1)}>Increment Count</button>
                 <p>Count: {count}</p>
               </div>
             );
           }

           const value = useMemo(expensiveFunction, [...dependencyArray])


            <!--- //////const [dependentCount, setDependentCount] = useState(10);////// ---!>


           const value = useMemo(calculate, [dependentCount]);

           return (
             <div className="App">

               // ...

               <button onClick={() => setDependentCount(dependentCount + 1)}>
                 Increment Dependent Count
               </button>
               <p>Dependent Count: {dependentCount}</p>
             </div>
           );





> useCallback : 
  > Use when you want to memoize a function to ensure it does not get recreated unnecessarily.
  > Memoizes a callback FUNCTION and returns it.
  > Prevents unnecessary re-creations on re-renders.

  > const memoizedCallback = useCallback(() => doSomething(dependencies), [dependencies]);

  >EXAMPLE : 
             import React, { useCallback, useState } from 'react';

             function Button({ onClick, label }) {
               return <button onClick={onClick}>{label}</button>;
             }

             function App() {
               const [count, setCount] = useState(0);

               const handleClick = useCallback(() => {
                 setCount(count + 1);
               }, [count]);

               return (
                 <div>
                   <p>Count: {count}</p>
                   <Button onClick={handleClick} label="Increment" />
                 </div>
               );
             }